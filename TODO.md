cami_wrap_struct ->
cami_impl
- we do NOT need a wrapper
- we ONLY need impl CamiPartialEq + CamiOrd

core_wrap_tuple ->
cami_tuple
cami_struct
-- may be NOT needed at all - see `Cami`
-- BUT then users can't `impl` any 3rd party traits for `Cami<T>`
-- WHILE, if **users** define a type (possibly generated by a macro), they can `impl` anything

`Cami`
- a universal (generic) wrapper (tuple)?
- `impl Copy for Cami<T> where T: Copy {};`
- Deref/DerefMut/DerefPure + From

Then core/alloc/std + for 3rd party:
`type StringCami = Cami<String>;`
- 3rd party can define their `type` aliases easily

trait `CamiCast` OR `IntoCami`
- a trait that adds `.into_cami()` to `core/alloc/std/custom`
- it has a `type CAMI`??

`Cami<[xyz; N]>` !== `[Cami<xyz>; N]`
`Cami<Vec<T>>`   !== `Vec<Cami<T>>`
`Cami<&[T]>`     !== `&[Cami<T>]`
- Usually we want the second one, so we can apply `Cami` ordering to the items.


feature??: casts (transmutes)

#[cfg_attr(doc_cfg, doc(cfg(any(feature = "full", feature = "derive"))))]
